# 面向对象的基本原则

面向对象的3个基本要素：封装、继承、多态。面向对象的5个基本设计原则：单一职责原则、开放封闭原则、依赖倒置原则、接口隔离原则和Liskov替换原则。所有的设计模式，均遵循着面向对象的基本原则；所有的设计模式，均实现面向对象的基本原则；二者相辅相成，理解面向对象的基本原则是理解设计模式的终极钥匙。

## 面向对象的5条基本原则

### 单一职责原则

单一职责原则的核心思想是：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。

专注是优良的品质和基因，个人足够专注能释放惊人的能量，组织足够专注能过关斩将。过多的变化因子和职责因子将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。

最佳实践：对类、模块有清晰的职责和协作的合理划分。

### 开放封闭原则

开放封闭原则的核心思想是：软件实体应该对修改封闭，对扩展开放。开放封闭原则主要体现在两个方面：1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。

实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定，即面向接口变成。系统最好依赖稳定的实体，即抽象的实体；利用面向对象的继承和多态机制，通过覆写其方法来改变固有行为，以扩展功能支持新的变化。封闭开放原则除了能保持软件内部的封装体系相对稳定，还有足够的灵活性能够通过扩展满足新的变化。对于开放封闭原则，它是面向对象所有原则的核心，软件设计说到底追求的目标就是封装变化、降低耦合，而开放封闭原则就是这一目标的最直接体现。

### 依赖倒置原则

大的软件系统包含若干子系统，子系统之间的耦合关系，往往导致系统的灵活性降低，诸如：底层改变一个软硬件平台将导致一些具体的实现发生变化，如果高层依赖底层，这种变化将导致逐层的更改。依赖倒置原则使用抽象不应该依赖于细节，细节应该依赖于抽象的策略彻底解决了这种耦合困境。

依赖倒置原则的核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。

我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。

### 接口隔离原则

接口隔离原则的核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。

接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。

分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。

### Liskov替换原则

Liskov提出了关于继承的原则：Inheritance should ensure that any property proved about supertype objects also holds for subtype objects.----继承必须确保超类中所拥有的性质在子类中仍然成立。2002年，软件工程大师Robert C. Martin出版了一本《Agile Software DevelopmentPrinciples Patterns and Practices》，在文中他把里氏代换原则最终简化为一句话：“Subtypes must be substitutable for their base types”也就是说子类必须能够替换成他们的基类。

Liskov替换原则的核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。Liskov替换原则着眼于抽象和多态特性：在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。

实现开放封闭原则的关键是抽象，而继承关系又是抽象的一种具体实现，从这个角度Liskov替换原则是实现开放封闭原则的具体规范。Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。

## 注意事项

> 你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。     -- ARTHUR J.RIEL《OOD启示录》
以上就是5个基本的设计原则，它们就像面向对象程序设计中的最基本原则，遵守它们可以使我们的系统架构合理，易于复用和扩展。不遵循他们，就没有了设计的灵魂和美感。

## 系列文章

- [CSDN专栏: 设计模式(UML/23种模式)](https://blog.csdn.net/column/details/27399.html)
- [Github专栏: 设计模式(UML/23种模式)](https://github.com/media-tm/MTDesignPattern)

## 参考文献

- [GOF的设计模式：可复用面向对象软件的基础](http://item.jd.com/10057319.html)
- [设计模式之禅](http://item.jd.com/11414555.html)
- [图说设计模式](https://github.com/me115/design_patterns)